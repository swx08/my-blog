import{_ as s,o as i,c as a,a7 as n}from"./chunks/framework.DaTdCRDa.js";const y=JSON.parse('{"title":"Redisson分布式锁","description":"","frontmatter":{"title":"Redisson分布式锁","author":"技术解码","readingTime":true,"date":"2024-07-20T00:00:00.000Z","tag":["redis"],"categories":["redis"]},"headers":[],"relativePath":"redis/Redisson实现分布式锁.md","filePath":"redis/Redisson实现分布式锁.md","lastUpdated":null}'),l={name:"redis/Redisson实现分布式锁.md"},t=n(`<h1 id="redisson分布式锁" tabindex="-1">Redisson分布式锁 <a class="header-anchor" href="#redisson分布式锁" aria-label="Permalink to &quot;Redisson分布式锁&quot;">​</a></h1><h1 id="介绍" tabindex="-1">介绍 <a class="header-anchor" href="#介绍" aria-label="Permalink to &quot;介绍&quot;">​</a></h1><p><strong>Redisson</strong>是一个在Redis的基础上实现的Java驻留（in-memory）数据网格（In-Memory Data Grid）。它不仅仅是一个客户端，而是一个完整的Redis服务Java实现。Redisson提供了许多分布式Java对象和服务，包括分布式锁、分布式集合、分布式执行服务、发布/订阅模式等。这些服务都使用了Redis作为底层的数据存储和消息传递机制。</p><p>Redisson通过Java实现了Redis的大部分命令，并且提供了丰富的API来操作Redis数据。它支持Redis的集群模式，可以在多个Redis节点之间自动进行数据的分片、复制和故障转移，从而实现高可用性和可扩展性。</p><p>使用Redisson，开发者可以更加方便地在Java应用中使用Redis的各种特性，而无需关心底层的Redis通信细节。同时，Redisson还提供了许多高级的分布式功能，使得开发者可以更加轻松地构建分布式应用。</p><p>请注意，虽然Redisson是一个强大的Redis Java客户端库，但它并不是Redis的官方Java客户端。Redis的官方Java客户端是Jedis。然而，Jedis只提供了Redis的基础功能，而Redisson则提供了更多高级的分布式功能。因此，在选择Redis的Java客户端时，需要根据项目的实际需求来决定使用哪个库。</p><h1 id="分布式锁" tabindex="-1">分布式锁 <a class="header-anchor" href="#分布式锁" aria-label="Permalink to &quot;分布式锁&quot;">​</a></h1><p><strong>Redisson分布式锁</strong>可以解决多个场景中的问题，主要体现在以下几个方面：</p><ol><li><strong>资源互斥访问</strong>：在分布式应用程序中，当多个节点或线程需要访问共享资源时，如果不加以控制，可能会导致数据不一致或其他并发问题。Redisson分布式锁可以确保在同一时间只有一个线程或节点可以访问和修改资源，从而防止多个节点同时修改共享数据。</li><li><strong>临界区保护</strong>：对于某些关键的代码段或操作，需要确保在执行过程中不会被其他线程或节点打断。使用Redisson分布式锁可以保护这些临界区，确保在锁释放之前，没有其他线程或节点能够进入并执行这些操作。</li><li><strong>分布式任务调度与事务</strong>：在分布式系统中，经常需要协调多个节点或任务以完成某项工作。Redisson分布式锁可以用于同步这些任务或事务的执行，确保它们在正确的顺序和时机下执行，避免出现冲突或不一致的情况。</li><li><strong>并发控制</strong>：对于高并发的场景，Redisson分布式锁可以有效地控制并发访问的数量，确保系统能够平稳地处理大量的请求。通过合理地分配锁和释放锁，可以避免资源过度消耗或系统崩溃的情况。</li><li><strong>减少线程阻塞和唤醒开销</strong>：在某些短时间内竞争激烈的场景中，使用Redisson分布式锁可以减少线程阻塞和唤醒的开销，提高系统的响应速度和吞吐量。</li></ol><p>总之，Redisson分布式锁适用于需要确保资源互斥访问、保护临界区、协调分布式任务调度与事务、控制并发访问以及减少线程阻塞和唤醒开销的场景。通过使用Redisson分布式锁，可以大大提高分布式系统的稳定性和可靠性。</p><h1 id="demo" tabindex="-1">Demo <a class="header-anchor" href="#demo" aria-label="Permalink to &quot;Demo&quot;">​</a></h1><p>商城项目中一般要对购买的商品进行减库存的操作，如何保证多个线程对同一个商品进行减库存操作时商品的库存数不会出现超卖的现象呢？我们可以使用Redisson分布式锁解决商品超卖问题！简单几行代码搞定…</p><h2 id="引入redisson依赖" tabindex="-1"><strong>引入Redisson依赖</strong> <a class="header-anchor" href="#引入redisson依赖" aria-label="Permalink to &quot;**引入Redisson依赖**&quot;">​</a></h2><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;org.redisson&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;redisson-spring-boot-starter&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;3.23.5&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="测试" tabindex="-1">测试 <a class="header-anchor" href="#测试" aria-label="Permalink to &quot;测试&quot;">​</a></h2><p><strong>测试前商品库存为20</strong></p><p><img src="https://s2.loli.net/2024/06/09/XMkdpJDIvPLrVeW.png" alt=""></p><p><strong>使用jmeter工具测试</strong></p><p>我们定义了100个线程数去进行减库存的操作。</p><p><img src="https://s2.loli.net/2024/06/09/MZ9HVUvqr5xuPOI.png" alt=""></p><h3 id="未加锁" tabindex="-1">未加锁 <a class="header-anchor" href="#未加锁" aria-label="Permalink to &quot;未加锁&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> decreaseStock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        //查询商品库存</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        Goods goods </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> baseMapper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">selectById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(goods.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getNum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            baseMapper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateWithConstom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;减库存成功&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;减库存失败&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><strong>出现超卖现象</strong></p><p><img src="https://s2.loli.net/2024/06/09/6Dp9i4kdGqXSaZf.png" alt=""></p><h3 id="加锁" tabindex="-1">加锁 <a class="header-anchor" href="#加锁" aria-label="Permalink to &quot;加锁&quot;">​</a></h3><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> decreaseStock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id) {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         * getLock()使用的是Redisson的普通分布式锁（RLock），</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         * 它在竞争锁时没有保证公平性。这意味着多个客户端同时请求锁时，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         * 任何一个客户端都有可能获得锁，这可能会导致某些客户端长时间等待。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        RLock clientLock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> redissonClient.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getLock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;goods:&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         * getFairLock()使用的是Redisson的公平分布式锁（FairLock），</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         * 它在竞争锁时保证了锁的公平性。这意味着按照客户端请求锁的顺序来分配锁，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         * 先请求锁的客户端会先获得锁，这样可以避免某些客户端长时间等待。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         * 需要注意的是，公平锁在性能上通常会略低于普通锁，因为它需要维护请求锁的队列和顺序，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         * 所以在选择锁机制时需要根据实际需求进行权衡。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">         */</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // RLock clientLock = redissonClient.getFairLock(&quot;goods:&quot; + id);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //加锁</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            clientLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //查询商品库存</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            Goods goods </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> baseMapper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">selectById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(goods.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getNum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                baseMapper.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">updateWithConstom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(id);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;减库存成功&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                log.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">info</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;减库存失败&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">            //释放自己的锁</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(clientLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isHeldByCurrentThread</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                clientLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><p><strong>未出现超卖现象</strong></p><p><img src="https://s2.loli.net/2024/06/09/nD8xiHqtWy5j2QU.png" alt=""></p><h1 id="疑问" tabindex="-1">疑问？ <a class="header-anchor" href="#疑问" aria-label="Permalink to &quot;疑问？&quot;">​</a></h1><p>是否已经彻底解决商品超卖问题了呢？</p><p>虽然<strong>Redisson的分布式锁</strong>可以在很大程度上减少或避免商品超卖问题的发生，但并不能完全“彻底”解决超卖问题。这是因为在实际应用中，超卖问题可能受到多种因素的影响，包括但不限于：</p><ol><li><strong>锁粒度</strong>：锁的粒度决定了它所能提供的并发控制级别。在上述代码中，锁是以商品ID为键的，这意味着对于同一件商品的所有并发请求都会被同一个锁控制。但是，如果锁的粒度设置得过细或过粗，都可能影响并发控制的效果。</li><li><strong>网络延迟</strong>：网络延迟可能导致锁的请求和释放操作不是立即生效的。这种情况下，即使有锁机制，仍然有可能发生超卖。</li><li><strong>数据库并发控制</strong>：分布式锁通常用于保护对共享资源的访问，但资源本身（如数据库）也可能有自己的并发控制机制（如事务隔离级别）。如果数据库层面的并发控制不当，也可能导致超卖。</li><li><strong>锁释放失败</strong>：在<code>finally</code>块中释放锁是一个很好的做法，但如果在释放锁的过程中出现异常（比如网络问题或Redis服务器故障），那么锁可能不会被正确释放，从而导致其他线程或进程无法获得锁，进而影响业务的正常进行。</li><li><strong>代码逻辑错误</strong>：如果代码中存在逻辑错误，比如查询库存和更新库存不是原子的，那么即使使用了锁，也可能出现超卖的情况。</li></ol>`,32),h=[t];function p(e,k,d,r,E,o){return i(),a("div",{"data-pagefind-body":!0,"data-pagefind-meta":"base64:JTdCJTIydGl0bGUlMjIlM0ElMjJSZWRpc3NvbiVFNSU4OCU4NiVFNSVCOCU4MyVFNSVCQyU4RiVFOSU5NCU4MSUyMiUyQyUyMmF1dGhvciUyMiUzQSUyMiVFNiU4QSU4MCVFNiU5QyVBRiVFOCVBNyVBMyVFNyVBMCU4MSUyMiUyQyUyMnJlYWRpbmdUaW1lJTIyJTNBdHJ1ZSUyQyUyMmRhdGUlMjIlM0ExNzIxNDMzNjAwMDAwJTJDJTIydGFnJTIyJTNBJTVCJTIycmVkaXMlMjIlNUQlMkMlMjJjYXRlZ29yaWVzJTIyJTNBJTVCJTIycmVkaXMlMjIlNUQlN0Q="},h)}const c=s(l,[["render",p]]);export{y as __pageData,c as default};
